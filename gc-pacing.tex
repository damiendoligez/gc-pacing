\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bbding}
\usepackage{hyperref}

\begin{document}

\title{GC control loop for OCaml 5\\
Design document}
\author{Stephen Dolan and Damien Doligez}
\date{\today}


\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Prerequisites and assumptions}
\label{prerequisites}

\begin{itemize}
\item[\Checkmark] Stephen Dolan's mark-delay patch (rebased and adapted by Nick
Barnes, \href{https://github.com/ocaml/ocaml/pull/13580}{\#13580}),
which delays the marking of roots until sweeping is mostly done. We'll
make the simplifying assumption that sweeping is completed before the
roots are marked.
\item Stephen Dolan's accounting patch,
\href{https://github.com/oxcaml/oxcaml/pull/3618}{oxcaml\#3618}, which
ensures that the work done to mark the roots and the marking work done by the
write barrier are counted as normal marking work.
\item[\Checkmark] Sadiq Jaffer's patch,
\href{https://github.com/ocaml/ocaml/pull/13616}{\#13616}, which ensures that
the sweeping work is independent of the size and shape of the free
list (formally, it is bounded by a linear function of
live$+$garbage). Note that this may also be covered by
\href{https://github.com/oxcaml/oxcaml/pull/3618}{oxcaml\#3618}. To
be checked in \verb'shared_heap.c/pool_sweep'.
\item Another patch to change the ephemeron GC work accounting. The
marking of ephemerons should be counted as normal marking (each block
counting for its size when it gets marked). This is to get rid of
arbitrary (up to quadratic) amounts of work when the structure of
ephemeron graphs is complex. The upside is that this will make the GC
behaviour predictable (in terms of space), the downside is that the GC
pauses will have less-predictable length, hurting the worst-case
latency of pauses. In practice this should not be a problem because
the users of ephemerons (therorem-provers) are not dependent on
real-time behaviour.
\item Yet another patch to insert an Idle phase between Sweep and
Mark. In this phase, the GC does not do any work while the mutator is
allocating as usual.
\end{itemize}

We assume the following properties of the OCaml runtime:
\begin{itemize}
\item OCaml 5 ensures that the sweeping work is constant during one GC cycle
(i.e. allocations done during sweeping do not increase work-to-do).
\item The heap is large enough and the mutator allocations are smooth
enough that we can ignore all quantization issues and treat all
numbers as reals.
\end{itemize}

About words: we count allocations and work in units of (heap) words,
including header and contents of each block. For marking and sweeping
work, treating one block is counted as a number of work units equal to
its size (with header). This is a simple-minded model of the actual
cost of doing the work. It allows us to bound the time spent in a
slice (hence the maximum latency of the GC) although it doesn't give a
very good uniformity (the latency distribution is rather wide).

When we talk about \emph{amount of data} we indicate a number of
words (allocated or collected, live or dead, etc.) including the
header words.

Steady-state assumption (SSA): whenever $x$
words are allocated by the mutator, $x$ (other) words are made
unreachable. This is a simplifying assumption that lets us study the
optimal solution to our problem: make the program use an amount of
memory proportional to the size of the live data. We expect most
programs to have at least some phases that violate this
assumption. The GC behaviour during these phases will be studied in
another document.

A GC cycle is composed of the following points and phases:
\begin{itemize}
\item (point) \emph{beginning of cycle $n$}, rotation of the colours
\item Sweep phase
\item Idle phase
\item (point) marking of roots
\item Mark phase
\item (point) \emph{end of cycle $n$, beginning of cycle $n+1$}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simple heap}
In this section we study the case of a program that does not make use
of custom blocks or ephemerons.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notations}

We define the following variables:

\bigskip
$o$ is the \verb'overhead' parameter of the runtime system, given by
the user.

$L_n$ is the amount of live (marked and reachable) data at the
beginning of cycle $n$

$F_n$ is the amount of floating garbage (marked and unreachable) at
the beginning of cycle $n$

$G_n$ is the amount of collectible garbage (unmarked and unreachable)
at the beginning of cycle $n$

$S_n$ is the amount of data allocated during the Sweep phase of cycle
$n$

$I_n$ is the amount of data allocated during the Idle phase of cycle
$n$

$M_n$ is the amount of data allocated during the Mark phase of cycle
$n$

$s$ is the amount of GC work done per word allocated in the Sweep phase

$m$ is the amount of GC work done per word allocated in the Mark phase

\bigskip

Note that $s$ and $m$ are the control parameters of the GC: in each
major GC slice, we know how much the program allocated since the
latest slice, and we have to decide how much GC work to do in
reaction.

\bigskip

\begin{equation}\label{def-beta}
\beta = o/100
\end{equation}
This is the overhead setting expressed in a convenient unit.

\begin{equation}\label{def-sigma}
\sigma = s/m
\end{equation}
This is the ratio of sweeping to marking ``speed''. This
will be chosen to make the GC pauses of the Sweep and Mark phases
approximately equal in real-time. This is normally larger than 1
because it turns out that the GC code needs to do more work to mark
$x$ words of memory than to sweep the same amount. Note that this
ratio is a function of the GC code rather than the memory behaviour of
the program. We will choose a reasonable constant after studying the
run-time behaviour of the code.

\begin{equation}\label{def-O}
O_n = F_n + G_n
\end{equation}
We call this \emph{raw overhead}. This is our measure of the memory
overhead of the system. It is
composed of all the garbage that is present at the  beginning of the
GC cycle. In an ideal world, the free list is empty at the beginning
of the cycle because we are starting to Sweep and replenish the free
list. In reality, the free list may be non-empty, and there will be
other overhead caused by auxiliary data structures and
fragmentation. Since these cannot be controlled by changing the GC
speed, we keep them out of our equations.

%% \begin{equation}\label{def-A}
%% A_n = L_n + O_n
%% \end{equation}
%% We call this the \emph{active heap size}. This is the "ideal" size of
%% the heap, ignoring fragmentation and free-list overheads.

\begin{equation}\label{def-Q}
Q_n = O_n/L_n
\end{equation}
This is the relative overhead: how much more memory we need per word
of live data.

The goal of the GC pacing system is to choose $s$ and $m$ such that
$Q_n$ stays as close as possible to $\beta$, so we will look for a
solution with the constraint:
\begin{equation}\label{beta-Q}
Q = \beta
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Steady state}

From the SSA, we immediately deduce that $S_n$, $I_n$, $M_n$ are also
the amounts of garbage created during the Sweep, Idle, Mark phases
respectively. We also get:
\begin{equation}
  L_{n+1} = L_n
\end{equation}
and in fact the amount of live data is constant through the GC
cycle. We will drop the subscript and call this amount $L$.

Because the GC is a snapshot-at-beginning incremental GC, the floating
garbage at the beginning of cycle $n+1$ is what was allocated between
the marking of roots and the end of cycle $n$:
\begin{equation}\label{eqn-F}
  F_{n+1} = M_n
\end{equation}

The collectible garbage is composed of the floating garbage from the
previous cycle, plus what became unreachable before the marking of
roots:
\begin{equation}\label{eqn-G}
  G_{n+1} = F_n + S_n + I_n
\end{equation}

The amount of work done during Sweep must be equal to the amount of
live data plus the amount of garbage, because the free list is not
swept.
\begin{equation}\label{eqn-sS}
sS_n = L + F_n + G_n
\end{equation}

The amount of work done during Mark must be equal to the amount of
live data at root marking time, which is $L$. This is because data
allocated during marking is allocated marked and does not need to be
marked again.
\begin{equation}\label{eqn-mM}
mM_n = L
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Choice of I]{Choice of $I$}

$I_n$ is how long we keep the GC in Idle, measured in memory allocated
by the mutator during this time. We can choose whatever value we want
for $I_n$, it is not constrained by the equations above. We are
interested in running the GC in two modes:
\begin{itemize}
\item normal mode: when $L$ is reasonably large, we don't use the Idle
phase, so we set $I_n = 0$.
\item small-heap mode: when $L$ is very small,  we can avoid running
the major GC at full speed, at the cost of a small amount of memory
(raw overhead), even though that translates to an unbounded relative
overhead. To this end, we choose a constant J (for example, at the
same order of magnitude as the minor heap size) and decide we must
allocate J words before we start marking:
\begin{equation}\label{def-J}
  J = S_n + I_n
\end{equation}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Solving for s and m]{Solving for $s$ and $m$}

We can use the SSA to simplify notations: Assuming $o$ (and $\beta$),
$s$, $m$ are constant, we also have $L_n$, $M_n$, $F_n$ constant. We
write them as $L$, $M$, $F$ without subscript.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Normal mode}

In normal mode, we have $I_n = 0$, thus
\begin{equation}
\begin{split}
G_{n+1} & = F + S_n \\
        & = F + L/s + F/s + G_n/s
\end{split}
\end{equation}

This converges on a constant $G$ iff $s > 1$. When $s \leq 1$, the
sequence G will keep growing and memory use is unbounded.

We now assume $s > 1$. We also assume that $G_n$ has converged to its
limit, which we call $G$.

$S_n$, $O_n$, $A_n$, $Q_n$ are now constants too, we'll write $S$,
$O$, $A$, $Q$.

We get the following equations:

\begin{gather*}
Q = \beta      \\
\sigma = s/m   \\
I = 0          \\
Q = O / L      \\
O = F + G      \\
G = F + S + I  \\
F = M          \\
sS = L + F + G \\
mM = L
\end{gather*}

These equations are mostly linear and we can eliminate all the
uppercase variables to get\footnote{
Checked by Rocq, with the additional conditions
$L \neq 0$,
$s \neq 0$,
$Q \neq 0$
}
\begin{gather*}
s = 1 + (2\sigma + 1)/\beta \\
m = s/\sigma
\end{gather*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Small-heap mode}
From \eqref{eqn-G} and \eqref{def-J} we get:
\begin{equation}
G_{n+1} = F + J
\end{equation}

$G$ is again constant, and so are $S$, $I$, $O$, $Q$. We get the
following equations:
\begin{gather*}
J = S + I      \\
O = F + G      \\
A = L + O      \\
sS = L + F + G \\
mM = L \\
Q = O/L \\
F = M \\
G = M + J \\
\end{gather*}

We get\footnote{Checked by Rocq, with the additional conditions
$I \ge 0$,
$s > 0$
}
\begin{gather*}
A = sJ - sI \\
A \leq sJ
\end{gather*}


This gives us a nice bound on the active heap size, which is also a
bound on the absolute overhead.

The relative overhead will be:
\begin{equation}\label{small-heap-Q}
  Q = 2/m + J/L
\end{equation}
As expected, this can get arbitrarily large as L approaches 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Smooth transition between modes}

At the transition between modes, we have $I = 0$ and $J =
S$. Computing $Q$ from the small-heap formula \eqref{small-heap-Q}, we
get:
\begin{equation}
  Q = (2\sigma+1)/(s-1)
\end{equation}
which is also the Q value from the normal mode, so there is no
discontinuity between the modes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Managing off-heap memory}

Off-heap memory is memory allocated outside the heap, but linked from
the heap. Since it gets deallocated (typically through finalisers)
when the corresponding heap blocks are freed, it is in fact managed by
the GC. We want the GC pacing logic to take it into account. Off-heap
memory is normally managed through custom blocks, most importantly
bigarrays (but also I/O buffers, etc.).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notations}

We define a few more variables:

\bigskip
$L'_n$ is the amount of off-heap live data (linked from live
heap blocks) at the beginning of cycle $n$

$F'_n$ is the amount of off-heap floating garbage (linked from
floating garbage heap blocks and not live) at the beginning of
cycle $n$

$G'_n$ is the amount of off-heap collectible garbage (linked only from
collectible garbage heap blocks) at the beginning of cycle $n$

$S'_n$ is the amount of off-heap data allocated during the Sweep phase
of cycle $n$

$I'_n$ is the amount of off-heap data allocated during the Idle phase
of cycle $n$

$M'_n$ is the amount of off-heap data allocated during the Mark phase
of cycle $n$

We introduce two more control parameters for the GC:

$s'$ is the is the amount of GC work done per off-heap word allocated
in the Sweep phase

$m'$ is the is the amount of GC work done per off-heap word allocated
in the Mark phase

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Strenthening the SSA}

We complete the SSA with a new assumption:

Extended steady-state assumption (SSAx): Whenever $x'$ words are
allocated off-heap, $x'$ (other) off-heap words become unreachable.

We also introduce the Allocation Rate Assumption (ARA): that the ratio
of off-heap to on-heap allocations is a constant $e'$. We get:
\begin{equation}\label{eqn-S'}
S'_n = e' S_n
\end{equation}
\begin{equation}\label{eqn-I'}
I'_n = e' I_n
\end{equation}
\begin{equation}\label{eqn-M'}
M'_n = e' M_n
\end{equation}

From SSAx, we get:
\begin{equation}
L'_{n+1} = L'_n
\end{equation}
Thus the amount of off-heap live data is constant and we'll call it
$L'$.

We also have:
\begin{gather}
F'_{n+1} = M'_n    \label{eqn-F'} \\
G'_{n+1} = F'_n + S'_n + I'_n   \label{eqn-G'}
\end{gather}

The GC never touches or even looks at off-heap data, so the amount of
work to do isn't affected by off-heap data. Equations \eqref{eqn-sS} and
\eqref{eqn-mM} become invalid and are replaced with:
\begin{gather}
 sS_n + s'S'_n = L_n + F_n + G_n   \label{eqn-sS'} \\
 mM_n + m'M'_n = L_n   \label{eqn-mM'}
\end{gather}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{New definition of overhead}

We define the off-heap overhead to be all the off-heap garbage:
\begin{equation}\label{def-O'}
O'_n = F'_n + G'_n
\end{equation}

%% Likewise, we define the \emph{active off-heap size} $A'_n$ to be the
%% size of active off-heap memory, and $\dot{A}_n$ the total active
%% size:
%% \begin{equation}\label{def-A'}
%% A'_n = L'_n + O'_n
%% \dot{A}_n = A_n + A'_n
%% \end{equation}

We want to manage the on-heap and off-heap overhead as a whole, so we
define the total space overhead to be the sum of the two:
\begin{equation}\label{def-Obar}
 \dot{O}_n = O_n + O'_n
\end{equation}

Unlike $L$ (which is measured indirectly by the Mark and Sweep
phases), we notice that the magnitude of $L'$ has no influence on the
GC: the off-heap space is invisible to it. As a consequence, we will
use a definition of relative overhead that disregards $L'$: we make it
relative only to $L$.
For programs with a large $L'/L$ factor, this might be a problem because
the GC will aim for a very small overhead relative to the total live
size $L+L'$. Our best solution for the moment is to count on the user
to compensate by increasing the $o$ parameter.
\begin{equation}\label{def-Qbar}
\dot{Q}_n = \dot{O}_n / L_n
\end{equation}


The goal of the pacing logic is now to choose not only $s$ and $m$,
but also $s'$ and $m'$ to keep $\dot{Q}_n$ close to $\beta$.

We will choose $s'$ and $m'$ such that:
\begin{equation}\label{sigma-prime}
s' / m' = \sigma
\end{equation}
As noted above (\eqref{def-sigma}), the ratio between $s'$ and $m'$
should be chosen as a function of the real-time behaviour of the
marking and sweeping code. It doesn't change when the GC work is in
response to off-heap allocation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Choice of I and I']{Choice of $I$ and $I'$}

$I_n$ and $I'_n$ are related by the ARA and \eqref{eqn-I'}, so there's
only one
thing to choose. The interesting value is the total active size
$A + A'$ of the program rather than the way it is distributed between
on-heap and off-heap data. As before, we'll distinguish two modes:
\begin{itemize}
\item Normal mode: when $L+L'$ is reasonably large, we want to use
$I_n = I'_n = 0$
\item Small-memory mode: when $L+L'$ is small, we want to slow down
the GC by extending the Idle phase, and let the relative overhead get
larger than the user setting. As before, we choose one constant, now
called $\dot{J}$ and let:
\begin{equation}\label{eqn-Jbar}
\dot{J} = S_n + S'_n + I_n + I'_n
\end{equation}
In other words, we switch from Idle to Mark phase when
$\dot{J}$ words have been allocated (on- and off-heap) since the
beginning of the cycle.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Solving for s, m, s', m']{Solving for $s$, $m$, $s'$, $m'$}

Using SSAx, we have $L'$ constant; assuming $s'$ and $m'$ are constant
and using
\eqref{eqn-M'}, \eqref{eqn-F'}, \eqref{eqn-mM'}, we infer that
$M'$ and $F'$ are also constant.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Normal mode}

We have the following equations:
\begin{gather*}
S'_n = e'S_n \\
sS_n + s'S'_n = L + F + G_n \\
G_{n+1} = F + S_n
\end{gather*}

From which we get:
\begin{equation}
G_{n+1} = F + \frac{L + F + G_n}{s + e's'}
\end{equation}

This converges on a constant $G$ iff $s + e's' > 1$,
otherwise garbage grows unboundedly.

We now assume $s > 1$, which ensures $s + e's' > 1$ for all values of
$e'$, and we also assume that $G_n$ has converged to $G$.

$S_n$ is now constant, and so is $S'_n$. We'll write $S$ and $S'$.

From \eqref{eqn-S'}, \eqref{eqn-I'}, \eqref{eqn-M'}, \eqref{eqn-G'} we get:
\begin{equation}
G'_{n+1} = e' G_{n+1}
\end{equation}
Thus $G'_n$, $O'_n$, $A'_n$, $\dot{O}_n$, $\dot{Q}_n$ are
also constant, we'll write $G'$, $O'$, $A'$, $\dot{O}$,
$\dot{Q}$.

Our goal is now to keep $\dot{Q}$ close to $\beta$, so we replace
\eqref{beta-Q} with:
\begin{gather}
\dot{Q} = \beta \label{beta-Qbar}
\end{gather}

We have the following equations:
\begin{gather*}
 s = \sigma m \\
 s' = \sigma m'\\
 I = 0 \\
 I' = 0 \\
 M' = e' M \\
 S' = e' S \\
 F = M \\
 F' = M' \\
 G = F + S + I \\
 G' = F' + S' + I' \\
 sS + s'S' = L + F + G \\
 mM + m'M' = L \\
 O = F + G \\
 O' = F' + G' \\
 \dot{O} = O + O' \\
 \dot{Q} = \dot{O} / L \\
\end{gather*}

Solving for $s$ and $s'$ as a function of $\dot{Q}$, we get\footnote{
Checked by Rocq, with the additional conditions
$L \neq 0$,
$e' \ge 0$,
$s > 0$,
$s' > 0$,
$\dot{Q} \neq 0$
}
\begin{equation} \label{eqn-s'}
s + e' s' = 1 + (1+e') (2\sigma+1)/\dot{Q}
\end{equation}

If $e' = 0$ we get the same equation as in the simple heap. If $e' >
0$, we get to choose $s$ and $s'$ as a function of $e'$ and
$\dot{Q}$. It is convenient to choose $s$ independently of $e'$,
which means using the same solution as in the simple case:
\begin{equation} \label{solution-s'}
s = 1 + (2\sigma+1)/\beta
\end{equation}

This leaves us with
\begin{align}
s' & = (2\sigma+1)/\beta \\
s' & = s - 1
\end{align}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Small-memory mode}

In small-memory mode, we will keep the same $s$ and $s'$ as for normal
mode, and concentrate on the choice of $\dot{J}$.

We have the following equations:
\begin{gather*}
s = m \sigma \\
s' = m' \sigma \\
G = F + S + I  \\
G' = F' + S' + I'  \\
F' = M'  \\
F = M \\
S' = e'S \\
I' = e'I \\
M' = e'M \\
mM + m'M' = L \\
sS + s'S' = L + F + G \\
\dot{J} = S + S' + I + I'  \\
O = F + G  \\
O' = F' + G' \\
\dot{O} = O + O'  \\
s = 1 + (2\sigma+1)/\beta \\
s' = (2\sigma+1)/\beta \\
\end{gather*}

We get
\footnote{
Checked by Rocq with the additional conditions
$m' > 0$,
$\sigma > 0$,
$\beta > 0$,
$e' >= 0$,
$M >= 0$,
$L >= 0$
}
\begin{gather*}
\dot{O} \leq \dot{J} + \frac{2L}{m'} \leq \beta L + \dot{J} \\
\dot{O} \leq \dot{J} (2 + 2\sigma + \beta)
\end{gather*}

The first line shows that small-memory mode cannot add more than a
fixed amount of overhead $\dot{J}$, which is under direct control of
the user.

The second line provides an absolute bound expressed directly in terms
of $\dot{J}$ and $\beta$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Transition between the modes}

Our small-memory mode bound is pretty loose, so we can't say much
about the transition between the modes. We would like to prove that
it's continuous as a function of $I+I'$ but that's not obvious from
the formulas.

We would also like to give a bound on the size of live memory at the
transition point, to show that small-memory mode is indeed restricted
to small heaps. Unfortunately, there is no constraint on $L'$ in the
above equations, so at best we'll be able to bound $L$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ephemerons}

To deal with ephemerons, the GC has to maintain a global list of all
ephemerons, and uses two more phases, inserted between
the Mark phase and the end of the cycle:
\begin{itemize}
\item Ephe\_mark, where the GC repeatedly goes through the list of
ephemerons in order to mark their data alive according to some
conditions (wich are irrelevant here). In the worst case, this phase
will use time quadratic in the length of the list. Since this time
cannot be predicted, we choose to ignore it: treat this phase as a
part of the Mark phase, and count work units normally when blocks are
marked. Note that this degrades the real-time performance of the GC
for programs that make significant use of ephemerons with complex data
structures (plain weak arrays are not affected).
\item Ephe\_sweep, where the GC goes once through the list of
ephemerons to remove the garbage from the list and erase the weak
pointers as needed.
\end{itemize}

Note that ephemerons are in a way dual to off-heap memory: they do not
use memory, and they do add workload to the GC.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notations}

We add more notations:

\bigskip
$L''_n$ is the amount of live ephemerons at the beginning of cycle $n$.

$F''_n$ is the amount of floating garbage ephemerons at the beginning
of cycle $n$.

$G''_n$ is the amount of collectible garbage ephemerons at the
beginning of cycle $n$.

$S''_n$ is the amount of ephemerons allocated during the Sweep phase
of cycle $n$.

$I''_n$ is the amount of ephemerons allocated during the Idle phase
of cycle $n$.

$M''_n$ is the amount of ephemerons allocated during the Mark phase
of cycle $n$.

$W_n$, $W'_n$, $W''_n$ are the amounts of heap data, off-heap
data, ephemerons allocated during the Ephe\_sweep phase. (W stands for
``weak'')

$s''$ is the amount of GC work done per word of ephemerons allocated
during the Mark phase.

$m''$ is the amount of GC work done per word of ephemerons allocated
during the Mark phase.

$w$, $w'$, $w''$ are the amounts of work done per word of
heap data, off-heap data, ephemerons allocated during the Ephe\_sweep
phase.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Strenghtening the SSA (again)}

We introduce a new SSA for ephemerons:

Steady-state assumption for ephemerons (SSAw): Whenever $x''$
words of ephemerons are allocated, $x''$ (other) ephemeron words
become unreachable.

We also introduce the Allocation Rate Assumption for ephemerons
(ARAw): the ratio of ephemerons to on-heap allocations is a constant
$e''$. We get:
\begin{gather}
S''_n = e''S_n \label{eqn-S''} \\
I''_n = e''I_n \label{eqn-I''} \\
M''_n = e''M_n \label{eqn-M''} \\
W''_n = e''W_n \label{eqn-W''}
\end{gather}

We also extend the ARA to the Ephe\_sweep phase:
\begin{gather}
W'_n = e'W_n  \label{eqn-W'}
\end{gather}

From SSAw, we get:
\begin{equation}
L''_{n+1} = L''_n
\end{equation}

Thus the amount of ephemerons is constant and we'll call it $L''$.

We have to replace \eqref{eqn-F} and \eqref{eqn-F'} with:
\begin{gather}
F_{n+1} = M_n + W_n  \label{eqn-FW} \\
F'_{n+1} = M'_n + W'_n  \label{eqn-F'W}
\end{gather}

We also have:
\begin{gather}
F''_{n+1} = M''_n + W''_n  \label{eqn-F''} \\
G''_{n+1} = F''_n + S''_n + I''_n   \label{eqn-G''}
\end{gather}

Note that,
at the beginning of Ephe\_mark, the ephemeron list contains not only
all the marked ephemerons: live $L''$ and floating garbage of the next
cycle $F''_{n+1}$ but also all the garbage ephemerons of the next
cycle $G''_{n+1}$ that will be removed from the list in this phase
and reclaimed
during the Sweep phase of the next cycle. However, for the garbage
ephemerons, the GC does no work beyond removing them from the list,
unlike the other ones, for which it has to examine each field. Since
adding the term $G''_{n+1}$ to \eqref{eqn-W''} makes the stability
condition really hard
to study, we will simplify things by not counting them as work, thus
incurring another slight degradation of the real-time performance.

Equations
\eqref{eqn-sS'} and \eqref{eqn-mM'} become invalid and are replaced with:
\begin{gather}
sS_n + s'S'_n + s''S''_n = L + F_n + G_n \label{eqn-sS''}  \\
mM_n + m'M'_n + m''M''_n = L  \label{eqn-mM''} \\
wW_n + w'W'_n + w''W''_n = L'' + F''_{n+1}  \label{eqn-wW''}
\end{gather}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Overhead}

The ephemerons cause more GC work, but they do not occupy any memory
beyond what is already accounted for, so our definitions of overhead
does not need to be changed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{New parameters}

We have five more parameters to choose: $s''$, $m''$, $w$, $w'$,
$w''$, and the goal
is still to keep $\dot{Q}_n$ close to $\beta$.

As we will see, there is additional overhead associated to the amount
of live ephemerons present in the heap. To deal with this, we
introduce a new parameter $\beta''$ and change our goal from
\eqref{beta-Qbar} to:
\begin{gather}
\beta \leq \dot{Q} \leq \beta + \beta'' \label{beta''-Qbar}
\end{gather}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Choice of I, I', I'']{Choice of $I$, $I'$, $I''$}

Once again, $I$, $I'$, $I''$ are related by ARA and ARAw and
\eqref{eqn-I'} and \eqref{eqn-I''}, so we have only one variable to
set. We'll keep $\dot{J}$ as our primary variable.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Solving for s, s', s'', m, m', m'', w, w', w'']
{Solving for $s$, $s'$, $s''$, $m$, $m'$, $m''$, $w$, $w'$, $w''$}

Assuming $m''$ constant
and using \eqref{eqn-M'}, \eqref{eqn-M''},
\eqref{eqn-mM''} we conclude that $M$, $M'$, $M''$
are also constant.

Then, using \eqref{eqn-wW''}, \eqref{eqn-F''}, \eqref{eqn-W'},
\eqref{eqn-W''}, \eqref{eqn-FW}, \eqref{eqn-F'W} we get that $W$,
$W'$, $W''$, $F$, $F'$, $F''$ are constant.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Normal mode}

We have:
\begin{gather*}
S'_n = e'S_n \\
S''_n = e''S_n \\
sS_n + s'S'_n + s''S''_n = L + F + G_n \\
G_{n+1} = F + S_n
\end{gather*}

We get:
\begin{equation}
G_{n+1} = F + L/(s+s'e'+s''e'') + F/(s+s'e'+s''e'') + G_n/(s+s'e'+s''e'')
\end{equation}

This converges on a constant G iff $s+s'e'+s''e'' > 1$. We once again
assume $s > 1$, which ensures the condition is true for all values of
$e'$ and $e''$. We also assume that $G_n$ has converged to its limit,
which we again call $G$.

Then $S$, $S'$, $S''$, $G'$, $G''$, $O$, $O'$,
$\dot{O}$, $\dot{Q}$ are also constant.

We have the following:
\begin{align*}
s/m &= \sigma  &  s'/m' &= \sigma \\
I &= 0  &  I' &= 0  &  I'' &= 0  \\
 & & M' &= e'M  &  M'' &= e''M \\
 & & S' &= e'S  &  S'' &= e''S \\
F &= M + W  &  F' &= M' + W'  &  F'' &= M'' + W'' \\
G &= F + S + I  &  G' &= F' + S' + I' \\
O &= F + G  &  O' &= F' + G' & \dot{O} &= O + O' \\
\dot{Q} &= \dot{O}/L  & sS + s'S' + s''S'' &= L + F + G \\
             &         &  mM + m'M' + m''M'' &= L \\
             &         &  wW + w'W' + w''W'' &= L'' + F''
\end{align*}

Let us define the following intermediate variables to make the
formulas easier to handle:
\begin{gather}
\ddot{s} = s + e's' + e''s'' \\
\ddot{m} = m + e'm' + e''m'' \\
\ddot{w} = w + e'w' + e''w'' \\
\overline{s} = \ddot{s} - 1 \\
\overline{w} = \ddot{w} - e''
\end{gather}

We get:
\begin{gather}
\overline{s} S = L + 2(M + W) \\
\ddot{m}M = L \\
\overline{w}W = L'' + e'' M
\end{gather}

Then we can compute $\dot{O}$ as a function of $L$, $L''$, $e'$,
$e''$, M, $\overline{s}$, $\ddot{m}$, $\overline{w}$:

\begin{gather}
\dot{O} = (e'+1)(S + 2(M+W)) \\
\frac{\dot{O}}{e'+1}
 = \frac{L}{\overline{s}} + \frac{2(M+W)}{\overline{s}} + 2(M+W) \\
\frac{\dot{O}}{e'+1}
 = \frac{L}{\overline{s}} + 2(M+W)\frac{\ddot{s}}{\overline{s}} \\
\frac{\dot{O}}{e'+1}
 = \frac{L}{\overline{s}} + \frac{2L\ddot{s}}{\ddot{m}\overline{s}}
     + \frac{2(L''+e''M)\ddot{s}}{\overline{w}\overline{s}} \\
\frac{\dot{O}}{e'+1}
 = \frac{L}{\overline{s}} + \frac{2L\ddot{s}}{\ddot{m}\overline{s}}
     + \frac{2(L''+\frac{e''L}{\ddot{m}})\ddot{s}}{\overline{w}\overline{s}}
\end{gather}

\bigskip
\bigskip
\bigskip

We make some simplifying decisions in order to cut down the number of
variables: we make $\ddot{m}$ and $\overline{w}$ both proportional to
$\ddot{s}$ and introduce a new intermediate variable $\gamma$:
\begin{gather}
\ddot{m} = \ddot{s} / \sigma \label{eqn-ms} \\
\overline{w} = 2\ddot{s} / \gamma \label{eqn-ws}
\end{gather}

Then we get:
\begin{gather}
\frac{\dot{O}}{e'+1}
 = \frac{L}{\overline{s}} + 2\sigma\frac{L}{\overline{s}}
     + \gamma\frac{L'' + \frac{e''M}{\ddot{m}}}{\overline{s}}
\end{gather}

And finally\footnote{
Checked by Rocq, with the additional conditions
$\gamma \neq 0$,
$\sigma \neq 0$,
$e' \geq 0$,
$e'' \geq 0$,
$L \neq 0$,
$s > 0$,
$s' \geq 0$,
$s'' \geq 0$
}
\begin{gather}
\dot{Q}\overline{s} = (e'+1) (1 + 2\sigma + \gamma(\frac{L''}{L} + \frac{e''}{\ddot{m}}))
\end{gather}

$L''$ is the amount of live ephemerons and $L$ is the amount of live
data, which includes ephemerons. Thus $L''/L$ is between 0 and 1.
Likewise, $e''$ is between 0 and 1, and we have:

\begin{gather}
\frac{1}{\overline{s}}(e'+1)(1 + 2\sigma) \leq \dot{Q} \leq
\frac{1}{\overline{s}}(e'+1)(1 + 2\sigma + \gamma(\frac{L''}{L} + \frac{e''}{\ddot{m}}))
\end{gather}

We can take $L''$ and $e''$ out of the picture by loosening the upper
bound:
\begin{gather}
\frac{1}{\overline{s}}(e'+1)(1 + 2\sigma) \leq \dot{Q} \leq
\frac{1}{\overline{s}}(e'+1)(1 + 2\sigma + \gamma(1 + \frac{1}{m''}))
\end{gather}


By matching this against \eqref{beta''-Qbar}, we get:

\begin{gather}
\beta = \frac{1}{\overline{s}}(e'+1)(2\sigma+1) \\
\beta'' = \frac{1}{\overline{s}}(e'+1)\gamma(1+\frac{1}{m''})
\end{gather}

This gives :
\begin{gather}
\gamma = \frac{\beta''}{\beta}(2\sigma+1)\frac{m''}{m''+1} \label{eqn-gamma}
\end{gather}

Now we have:
\begin{gather}
\overline{s} = \frac{e'+1}{\beta}(2\sigma+1) \\
s - 1 + e's' + e''s'' = (e'+1)(2\sigma+1)/\beta
\end{gather}

This bound is attained in the absence of ephemerons (i.e. when
$L'' = e'' = 0$) and we then get:
\begin{gather}
s - 1 + e's' = (e'+1)(2\sigma+1)/\beta
\end{gather}

This is exactly equivalent to \eqref{eqn-s'} and we
have to choose the same $s$ and $s'$ as before for this to be true for
all values of $e'$. Thus we remain compatible with
ephemeron-free programs.

\begin{gather}
s = 1 + (2\sigma + 1)/\beta \\
s' = (2\sigma + 1)/\beta
\end{gather}

Note that the above does not constrain the value of $m''$ (or $s''$).
We use \eqref{eqn-ms} and \eqref{eqn-ws} to derive the remaining
coefficients:
\begin{gather}
m = s/\sigma \\
m' = s'/\sigma \\
w = 2s/\gamma \\
w' = 2s'/\gamma \\
w'' = 2s''/\gamma + 1
\end{gather}

Now we have to choose $s''$. If we set it close to 0, then $\gamma$
also goes to 0 and $w$, $w'$ get arbitrarily large. If we set
$s''$ to be very large, $m''$ will also be large. In the first
case, we get large latencies in the Ephe\_sweep phase, while in the
second case we get large latencies when allocating ephemerons in the
other phases.

In order to strike a balance between the two extremes (and to get
simpler formulas) we will choose $s'' = \sigma + 1$.

We then have:
\begin{gather}
\gamma = \frac{\beta''}{\beta}(\sigma + 1) \\
s'' = \sigma + 1 \\
m'' = s''/\sigma \\
\end{gather}

We can do a smoke check with some reasonable values for the
parameters:
\begin{gather}
\beta = 1 \\
\beta'' = 0.2 \\
\sigma = 3
\end{gather}

We get:
\begin{gather}
\gamma = 0.8 \\
s = 8 \\
s' = 7 \\
s'' = 4 \\
m = 2.67 \\
m' = 2.33 \\
m'' = 1.33 \\
w = 20 \\
w' = 17.5 \\
w'' = 11
\end{gather}
There is some imbalance between the phases, but there is not much to
gain by increasing $s''$, so the user may have to change $\beta''$ and
strike a balance between space overhead and latency. Note that
$\beta''$ is a really loose bound on the space overhead incurred by
ephemerons, since it is only approached (not even reached) when all
the heap data and allocations are made up of ephemerons.

The right user setting might be $\beta''/\beta$ rather than $\beta''$
itself, since the formulas only depend on the ratio.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Small-memory mode}


We have $G_{n+1} = F + S_n + I_n = F + J$, which is constant. Then $S$,
$S'$, $S''$, $G'$, $G''$, $O$, $O'$, $\dot{O}$, $\dot{Q}$
are also constant.

\bigskip

We have the following:
\begin{align*}
S+I &= J & S'+I' &= J' & \dot{J} = J + J' \\
 & & M' &= e'M  &  M'' &= e''M \\
 & & I' &= e'I \\
 & & W' &= e'W  &  W'' &= e''W \\
 & & S' &= e'S  &  S'' &= e''S \\
 s &= \sigma m  &  s' &= \sigma m'  &  s'' = \sigma m'' \\
 w &= 2s/\gamma  &  w' &= 2s'/\gamma  &  w'' = 2s''/\gamma + 1 \\
F &= M + W  &  F' &= M' + W'  &  F'' &= M'' + W'' \\
G &= F + S + I  &  G' &= F' + S' + I' \\
O &= F + G  &  O' &= F' + G' & \dot{O} &= O + O' \\
  &         & sS + s'S' + s''S'' &= L + F + G \\
             &         &  mM + m'M' + m''M'' &= L \\
             &         &  wW + w'W' + w''W'' &= L'' + F'' \\
 s &= 1 + (2\sigma +1)/\beta  &  s' &= (2\sigma+1)/\beta  &  s'' &=
 \sigma+1 \\
 \gamma &= (\sigma + 1)\beta''/\beta \\
\end{align*}

We can prove\footnote{
Checked by Rocq, with the additional conditions
$\sigma > 0$,
$\beta > 0$,
$\beta'' > 0$,
$e' \ge 0$,
$e'' \ge 0$,
$M \ge 0$,
$0 \le L'' \le L$.
}
\begin{gather}
\dot{O} \leq (\beta + \beta'')L + \dot{J}
\end{gather}

Once again, small-memory mode cannot add more than a
fixed amount of overhead $\dot{J}$, which is under direct control of
the user.

\end{document}

